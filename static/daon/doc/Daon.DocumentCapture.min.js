!(function (e) {
  'use strict'
  function t(e, t, s) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: s,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = s),
      e
    )
  }
  function s(e) {
    for (let s = 1; s < arguments.length; s++) {
      var i = arguments[s] != null ? arguments[s] : {}
      let a = Object.keys(i)
      typeof Object.getOwnPropertySymbols === 'function' &&
        (a = a.concat(
          Object.getOwnPropertySymbols(i).filter(function (e) {
            return Object.getOwnPropertyDescriptor(i, e).enumerable
          })
        )),
        a.forEach(function (s) {
          t(e, s, i[s])
        })
    }
    return e
  }
  const i = {
    captureInterval: 150,
    feedbackInterval: 2e3,
    width: 1280,
    height: 720,
    facingMode: 'environment',
    documentType: 'ID_CARD',
    returnDetectedImage: 'SUCCESS_ONLY',
  }
  const a = {
    1: { code: 901, message: 'Try to straighten up the document' },
    2: {
      code: 902,
      message: 'Position the document so that it fills the rectangle',
    },
    3: { code: 903, message: 'Try to straighten up the document' },
    4: { code: 904, message: 'Try to straighten up the document' },
    5: { code: 905, message: 'Try to straighten up the document' },
    6: {
      code: 906,
      message: 'Move the ID document away from strong discrete light sources',
    },
    7: {
      code: 907,
      message: 'Try to holder the document in a steady position',
    },
    8: {
      code: 908,
      message: 'Move the ID to a position where there is a plain background',
    },
    9: { code: 909, message: 'Try to straighten up the document.' },
    10: {
      code: 910,
      message: 'Too much movement, hold the document steady.',
    },
    11: {
      code: 911,
      message:
        'Could not find document, place the document in the scanning area.',
    },
    12: {
      code: 912,
      message: 'Move the ID document away from strong discrete light sources.',
    },
  }
  function r(e, t) {
    return fetch(e, {
      method: 'post',
      headers: { 'Content-Type': 'application/octet-stream' },
      body: t,
    }).then((e) => {
      if (e.ok || e.status === 400) return e.json()
      throw new Error(e.status + ' ' + e.statusText)
    })
  }
  const n =
    'You must set message priorities with configureMessagePriorities(yourConfig)'
  const o = 'You must set a timeout interval'
  const c = 'You must provide a callback'
  class u {
    constructor(e) {
      if (!e) throw n
      ;(this.messagePriorities = e), (this.queue = [])
    }

    pushArray(e) {
      Array.prototype.push.apply(this.queue, e)
    }

    getPriorityMessage() {
      return h(this.messagePriorities, this.queue)
    }

    enableAutoGetPriorityMessage(e, t) {
      if (!e || typeof e !== 'number') throw o
      if (!t || typeof t !== 'function') throw c
      return (
        (this.intervalId = setInterval(() => {
          this.intervalId && t(h(this.messagePriorities, this.queue))
        }, e)),
        this.intervalId
      )
    }

    disableAutoGetPriorityMessage() {
      clearInterval(this.intervalId)
    }
  }
  function h(e, t) {
    if (!e) throw n
    if (!t || !t.length) return
    let s = void 0
    for (let i = 1; i <= 12; i++) {
      const a = e[i]
      if ((s = t.find((e) => e && a && e.code === a.code))) break
    }
    return (t.length = 0), s ? s.message : void 0
  }
  function d(e) {
    return e ? e.getVideoTracks() : []
  }
  function g(e) {
    const t = d(e)
    return t.length ? t[0].getSettings() : {}
  }
  function m(e) {
    return !!d(e).find((e) => e.readyState === 'live')
  }
  class l {
    get videoTracks() {
      return d(this.stream)
    }

    get isReady() {
      return m(this.stream)
    }

    get settings() {
      return g(this.stream)
    }

    start(e, t) {
      return navigator.mediaDevices
        .getUserMedia({ video: e, audio: !1 })
        .then(
          (e) => (
            (this.stream = e),
            t && (this.videoEl = t),
            this.videoEl || (this.videoEl = document.createElement('video')),
            (this.videoEl.srcObject = e),
            this.videoEl
          )
        )
    }

    stop() {
      this.videoTracks.forEach((e) => e.stop())
    }
  }
  const p = 'Capture source not valid'
  class f {
    capture(e) {
      if (e && m(e.srcObject)) {
        return (
          this.canvas || (this.canvas = document.createElement('canvas')),
          (this.canvas.width = e.videoWidth),
          (this.canvas.height = e.videoHeight),
          this.canvas
            .getContext('2d')
            .drawImage(e, 0, 0, e.videoWidth, e.videoHeight),
          new Promise((e, t) => {
            try {
              this.canvas.toBlob((t) => e(t), 'image/jpeg', 1)
            } catch (e) {
              t(e)
            }
          })
        )
      }
      throw p
    }

    getImageData(e) {
      if (e && m(e.srcObject)) {
        this.canvas || (this.canvas = document.createElement('canvas')),
          (this.canvas.width = e.videoWidth),
          (this.canvas.height = e.videoHeight)
        const t = this.canvas.getContext('2d')
        return (
          t.drawImage(e, 0, 0, e.videoWidth, e.videoHeight),
          t.getImageData(0, 0, e.videoWidth, e.videoHeight)
        )
      }
      throw p
    }
  }
  const v = "Configuration 'url' is mandatory"
  const y = 'Camera not ready'
  class I {
    constructor() {
      ;(this.camera = new l()), (this.captureCanvas = new f())
    }

    startCamera(e, t) {
      this.messageCache = new u(this.qualityAssesmentMessages)
      const s = (function (e, t) {
        const s = {}
        return (
          e &&
            (t && (s.deviceId = { exact: t }),
            e.facingMode && !t && (s.facingMode = e.facingMode),
            e.height && (s.height = e.height),
            e.width && (s.width = e.width)),
          s
        )
      })(this.config, t)
      return this.camera.start(s, e).then(
        (e) => (
          (function (e, t) {
            const s = g(e.srcObject)
            let i = s && s.facingMode
            return (
              !i &&
                navigator.userAgent.match(
                  /(Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone)/i
                ) &&
                (i = t),
              i === 'user' || !i
            )
          })(e, this.config.facingMode) &&
            !t &&
            (function (e) {
              ;(e.style['-webkit-transform'] = 'scaleX(-1)'),
                (e.style.transform = 'scaleX(-1)')
            })(e),
          (function (e) {
            e.attributes.autoplay || e.setAttribute('autoplay', ''),
              e.attributes.playsinline || e.setAttribute('playsinline', '')
          })(e),
          { videoEl: this.camera.videoEl }
        )
      )
    }

    getUrl(e, t) {
      const { documentType: i, returnDetectedImage: a } = this.config
      return (function (e, t) {
        const s = new URL(e, window.location.origin)
        return (
          Object.keys(t).forEach((e) => t[e] && s.searchParams.append(e, t[e])),
          s
        )
      })(
        this.config.url,
        s({ documentType: i, returnDetectedImage: a, hintFacePresent: t }, e)
      )
    }

    startAutoCapture(e, t) {
      if (((this.queue = []), !this.camera.isReady)) throw y
      this.pendingPromise = void 0
      const s = () => {
        this.pictureTakingTimeoutId = setTimeout(() => {
          if (this.pictureTakingTimeoutId) {
            try {
              this.pendingPromise ||
                this.captureCanvas
                  .capture(this.camera.videoEl)
                  .then(
                    (s) => (
                      (this.pendingPromise = r(this.getUrl(), s)
                        .then((t) => {
                          if (t.result === 'PASS')
                            return (
                              this.stopAutoCapture(),
                              e(
                                (function (e, t) {
                                  return {
                                    result: t.result,
                                    sentBlobImage: e,
                                    responseBase64Image:
                                      t.documentImage && t.documentImage.image,
                                  }
                                })(s, t)
                              )
                            )
                          Array.prototype.push.apply(this.queue, t.feedback)
                        })
                        .catch((e) => {
                          this.stopAutoCapture(), t(e)
                        })
                        .finally(() => {
                          this.pendingPromise = void 0
                        })),
                      this.pendingPromise
                    )
                  )
                  .catch((e) => this.onCaptureError(e))
            } catch (e) {
              this.onCaptureError(e)
            }
            s()
          }
        }, this.config.captureInterval)
      }
      const i = () => {
        this.messageCleanupTimeoutId = setTimeout(() => {
          if (this.messageCleanupTimeoutId) {
            const t = h(this.qualityAssesmentMessages, this.queue)
            e({ result: 'FAIL', feedback: t }), i()
          }
        }, this.config.feedbackInterval)
      }
      s(), i()
    }

    onCaptureError(e) {
      throw (this.stopAutoCapture(), e)
    }

    stopAutoCapture() {
      clearTimeout(this.messageCleanupTimeoutId),
        clearInterval(this.pictureTakingTimeoutId)
    }

    capture() {
      return this.captureCanvas
        .capture(this.camera.videoEl)
        .then((e) => this.assessQuality(e))
    }

    captureFrame() {
      return this.captureCanvas.capture(this.camera.videoEl)
    }

    assessQuality(e, t, s) {
      if (!this.config || !this.config.url) throw v
      return r(this.getUrl(t, s), e).then((t) => {
        const s = {
          result: t.result,
          sentBlobImage: e,
          responseBase64Image: t.documentImage && t.documentImage.image,
          message: t.message,
        }
        return (
          t.result === 'FAIL' &&
            (s.feedback = h(this.qualityAssesmentMessages, t.feedback)),
          s
        )
      })
    }

    stopCamera() {
      this.camera.stop()
    }

    isReady() {
      return this.camera.isReady
    }
  }
  class b extends I {
    constructor(e) {
      super(), (this.config = s({}, i, e)), (this.qualityAssesmentMessages = a)
    }
  }
  ;(b.VERSION = '1.1.8'), (e.DocumentCapture = b)
})((this.Daon = this.Daon || {}))
